function cm = warmrainbow(n,brightness,contrast);% warmrainbow;% warmrainbow(n);% warmrainbow(n,brightness,contrast);%% better than jet. Still looks like a rainbow when n ~ 10; minimizes the% luminance peak at cyan, and puts the luminance peak at yellow in the middle;% and still looks like a rainbow when the value channel is made uniform, so% shades of this colormap can be used to encode a second information dimension).%% neil banas, dec 2006%% default n=20% default brightness (value of yellow) = .9% default contrast (difference between yellow value and red-blue value) = .3if nargin < 3, contrast = .3; endif nargin < 2, brightness = .9; endif nargin < 1, n = 20; endresz = 0;if ~mod(n,2) % if n is even, calculate an odd-length colormap and then shorten	% 				the red side: this preserves the yellow color	resz = 1;	n=n+1;endHbyr = [.55 1/6 0]; % blue yellow red huesVbyr = [brightness-contrast, brightness, brightness-contrast]; % blue yellow red valuesW = 1.5; % width of the dip in saturation over greenx = 0:n-1;nh = floor(n/2);nh2 = ceil(n/2);hue = nan.*ones(n,1); sat = hue; val = hue;N=n-1;b = (8*Hbyr(2)-7*Hbyr(1)-Hbyr(3))/N^2;a = (Hbyr(3)-Hbyr(1))/N^3 - b/N;hue = a.*x.^3 + b.*x.^2 + Hbyr(1);hue(nh+1:end) = linspace(hue(nh+1),Hbyr(3),nh2);x0 = x(find(abs(hue-1/3)==min(abs(hue-1/3))));sat = 1-.5*exp(-(W.*(x./x0-1)).^2);b = 4*(Vbyr(2)-Vbyr(3))/N;c = Vbyr(3);a = -b/N;val = a.*x.^2 + b.*x + c;if Vbyr(1)~=Vbyr(2)	val(1:nh) = linspace(Vbyr(1),Vbyr(2),nh);else 	val(1:nh) = Vbyr(1);endcm = hsv2rgb([hue(:) sat(:) val(:)]);if resz % subsampling red side because an even length was requested	cm = interp1((1:n)',cm,[1:nh linspace(nh+1,n,nh)]');end	