function v = coltraneModel(forcing,p,whatToSave);

% v = coltraneModel(forcing, p, 'scalars only' | 'scalars and fitness' | 'everything');
%
% "dia19" (DIAPOD, 2019) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model in Banas et al., Front. Mar. Res., 2016.
%
% forcing is a structure specifying a single time series of forcing and 
% 		ancillary variables. Cohorts are generated by varying spawning date
% 		across the first year.
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * the state variables have been largely separated so that not all parts
% 		require iteration in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				1) development alone (D),
% 				2) then size and time evolution in surviving cohorts (D,W),
% 				3) then mortality, survivorship, and population dynamics (D,W,N,E).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are analyzed in a brute-force way parallel
% 		to spawning date.
% * tegg has been replaced by dtegg, which is similar to (tegg - t0).
%
%	t			t0			tdia_exit	tdia_enter	dtegg
%	timestep	spawn date	exit date	entry date	egg prod date
%	(calendar)	(calendar)	(yearday)	(yearday)	(relative to t0)
%
% the last three of these are folded into a single strategy vector s.


if nargin < 3, whatToSave = 'scalars only'; end

fields = fieldnames(forcing);
for i=1:length(fields)
	forcing.(fields{i}) = forcing.(fields{i})(:);
end
NT = size(forcing.t,1); % # timesteps
[t0,s] = timingCombinations(forcing,p);
strategyFields = fieldnames(s);
NC = length(t0);
NS = prod(size(s.(strategyFields{1})));


% run one strategy at a time
out = cell(1,NS);
disp([num2str(NT) ' timesteps x ' num2str(NC) ' cohorts x ' num2str(NS) ' strategies']);
parfor i = 1:NS
	si = selectRows(s,i);
	out{i} = coltrane_integrate(forcing,p,t0,si,whatToSave);
end


% rearrange into something more useful. (_parfor_ prefers that we don't do all this
% fancy indexing inside the main loop over strategies 1:NS.)
for i = 1:NS
	v.F1(:,i) = out{i}.F1(:); % now [NC NS], not [1 NC NS]
	v.F2(:,i) = out{i}.F2(:);
	v.level(:,i) = out{i}.level(:);
end
f = find(any(v.level>0)); % strategies with any complete integrations
if isempty(f)
	% if there aren't any, return only level (and F1, F2 = 0)
	return;
end
fields = setdiff(fieldnames(out{f(1)}),{'F1','F2'});
for k = 1:length(fields)
	v.(fields{k}) = repmat(nan,size(out{f(1)}.(fields{k})));
	for i=1:NS
		if isfield(out{i},fields{k}) && ~isempty(out{i}.(fields{k})) ...
			v.(fields{k})(:,:,i) = squeeze(out{i}.(fields{k}));
		end
	end
end



