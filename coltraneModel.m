function [v,fl] = coltraneModel(forcing,p,chunkSize)

% v = coltraneModel(forcing,p);
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% forcing is a structure specifying a single time series of forcing and 
% 		ancillary variables. Cohorts are generated by varying spawning date
% 		across the first year.
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * This is actually an approximate solution which doesn't require iteration 
%		across all state variables in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,W),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are considered in a brute-force way parallel
% 		to spawning date.
% * tegg has been replaced by dtegg, which is similar to (tegg - t0):
%
%	NT			NC			NDx			NDn			NE
%	t			t0			tdia_exit	tdia_enter	dtegg
%	timestep	spawn date	exit date	entry date	egg prod date
%	(calendar)	(calendar)	(yearday)	(yearday)	(relative to t0)
%
% the last three dimensions are folded into a single strategy vector s.


if nargin<3, chunkSize = 500; end

% calculate yearday, if it wasn't supplied
if ~isfield(forcing,'yday')
	forcing.yday = reshape(yearday(forcing.t),size(forcing.t));
end
NT = size(forcing.t,1); % # timesteps


% vectors of timing parameters t0, tdia_exit, tdia_enter, dtegg
t0 = forcing.t(1) : p.dt_spawn : (forcing.t(end) - 365); % the spawning dates to consider
NC = length(t0);
tdia_exit = p.tdia_exit;
if isempty(tdia_exit)
    tdia_exit = 0 : p.dt_dia : 365/2; % diapause exit yeardays
end
NDx = length(tdia_exit);
tdia_enter = p.tdia_enter;
if isempty(tdia_enter)
    tdia_enter = (max(tdia_exit) + p.dt_dia) : p.dt_dia : 365; % entry dates
end
NDn = length(tdia_enter);
dtegg = p.dtegg;
if isempty(dtegg)
	dteggmin = (p.min_genlength_years - 0.5) .* 365;
	dteggmin = max(dteggmin, p.dt_spawn);
	dteggmax = (p.max_genlength_years + 0.5) .* 365;
	dteggmax = min(dteggmax, forcing.t(end) - t0(end));
	dtegg = dteggmin : p.dt_spawn : dteggmax;
		% the date that egg production begins relative to t0
end
NE = length(dtegg);


% construct the strategy vector _s_ (conceptually a vector, but in practice a
% structure)
[s.tdia_exit, s.tdia_enter, s.dtegg] = ndgrid(tdia_exit, tdia_enter, dtegg);
NS = NDx * NDn * NE; % total number of strategy combinations


% evaluate the full fitness landscape, one chunk of strategies at a time
ind0 = [(1 : chunkSize : NS) NS+1];
dF1 = nan([NT NC NS]);

dF1chunks = cell(1,length(ind0)-1);

for i = 1:length(ind0)-1
	ind = (ind0(i) : ind0(i+1)-1);
	si = selectRows(s,ind);
    dF1chunks{i} = coltrane_integrate(forcing,p,t0,si,'fitness only');
end


for i=1:length(dF1chunks)
	ind = (ind0(i) : ind0(i+1)-1);
	dF1(:,:,ind) = dF1chunks{i};
end
fl = fitnessLandscapeRooted(dF1,forcing.t,t0,s);
fl.forcing = forcing;
fl.p = p;

% filter strategy landscape by 2-gen fitness
fit = find(any(fl.F2 > p.fitnessFilter)); % s is a fit strategy if F2(t0,s)>1 for some t0
% disp([num2str(NS) ' strategies selected. Output structure will be about ' ...
% 	num2str(20*4*NT*NC*NS/1e9) ' GB.']);
s = selectRows(s, fit);

% the fitness landscape should also be filtered by 2-gen fitness
fl = fl_filter(fl,fit);




% rerun model, saving full output for the fit cohorts and strategies
%v = coltrane_integrate_noApprox_debug(forcing,p,t0,s,'everything');
% v = coltrane_integrate_noApprox_restrict_reserves_EuansCorrections(forcing,p,t0,s,'everything');
v = coltrane_integrate(forcing,p,t0,s,'everything');




% ------------------------------------------------------------------------------
function si = selectRows(s,ind)
    fields = fieldnames(s);
    for k=1:length(fields)
        si.(fields{k}) = s.(fields{k})(ind);
    end

function f = fl_filter(fl,ind)
    fields = fieldnames(fl);
    for k=1:length(fields)
        if ismember(fields{k}, {'dF1' 'dF2' 'F1' 'F2'})
            f.(fields{k}) = fl.(fields{k})(:,:,ind);
        elseif ismember(fields{k}, {'t0' 'tdia_exit' 'tdia_enter' 'dtegg'})
            f.(fields{k}) = fl.(fields{k})(:,ind);
        else
            f.(fields{k}) = fl.(fields{k});
        end
    end
