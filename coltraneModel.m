function v = coltraneModel(particles,p,ind);

% v = bcc_coltraneModel(particles,p,ind);
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% particles is a structure specifying time series of forcing and ancillary 
%		variables along particle paths. Cohorts are generated by varying 
%		spawning date across the first year.
%		Note that these do not have to move in space, and in fact the spatial
%		coordinates aren't used in any way--perhaps a better term would be
%		"histories" or "cases."
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%		A nice improvement to this code would be to allow the timing-strategy
%		parameters--tdia_enter, tdia_exit, and (in a future version that uses 
%		it) tegg--to be vectors. For now, handle these the same as if you want
%		to run ensembles across vectors of the other parameters, by writing a 
%		wrapper function that calls coltraneModel in a loop.
% ind is a list of the indices into _particles_ to use. This makes it easy to 
%		run subsets of a big particle-release experiment.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * This is actually an approximate solution which doesn't require iteration 
%		across all state variables in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,W),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause is still available, but you also can
%		specify diapause entry and exit dates--or rather, specify a matrix
%		of these, run them all in a brute-force way, and then pick the combo
%		that worked out best.


% setup ------------------------------------------------------------------------
% calculate yearday, if it wasn't supplied
if ~isfield(particles,'yday')
	particles.yday = reshape(yearday(particles.t),size(particles.t));
end
% keep only particles with indices _ind_
if nargin > 2
	fields = fieldnames(particles);
	for i=1:length(fields)
		particles.(fields{i}) = particles.(fields{i})(:,ind);
	end
end
% create cohorts by varying spawning date. This copies everything in _particles_
% over into the massive output structure v
[NT,NP] = size(particles.t); % # timesteps, # particles
dt = particles.t(2) - particles.t(1);
	% makes the simulation timestep match the forcing time series, rather than
	% the other way around.
	% this needs sorting out. Perhaps at this point interpolate all the fields
	% in _particles_ onto a new timebase specified by a parameter p.dt.
	% Note that the original Coltrane model ran with an internal timestep of
	% 0.5 d, but this was mainly to resolve sharp peaks in egg production in 
	% very short growing seasons--a much longer timestep might be just as good.
t0 = particles.t(1) + (0 : dt : 365); % the spawning dates to consider
NC = length(t0); % # spawning dates
fields = fieldnames(particles);
for i=1:length(fields)
	v.(fields{i}) = repmat(particles.(fields{i}),[1 1 NC]);
end
v.t0 = repmat(reshape(t0,[1 1 NC]),[1 NP 1]);
t0_3d = repmat(v.t0,[NT 1 1]);

% prey saturation --------------------------------------------------------------
v = preySaturation(v,p);	
	
% activity: a(t)  --------------------------------------------------------------
if p.myopicDiapause
	sat_crit = p.rm .* (1-p.rb) ./ p.r_assim ... 
			 + p.GGE_nominal .* p.m0_over_GGE_I0 .* p.r_assim;
	v.a = double(v.sat >= sat_crit);
else % an explicit range of yeardays
	if p.tdia_enter > p.tdia_exit
		v.a = ~(v.yday >= p.tdia_enter | v.yday <= p.tdia_exit);
	else
		v.a = ~(v.yday >= p.tdia_enter & v.yday <= p.tdia_exit);
	end 
end
% keep track of average prey saturation during the a=0 and a=1 periods-
% this isn't used in the model but could be a useful diagnostic
v.sata0 = sum(v.sat .* double(v.a==0)) ./ sum(double(v.a==0));
v.sata1 = sum(v.sat .* double(v.a==1)) ./ sum(double(v.a==1));


% temperature response factors -------------------------------------------------
% this has been simplified by assuming temp is independent of activity level,
% which is perhaps appropriate for shallow shelves but not for deep basins.
% to restore the Coltrane 1.0 behaviour, use an effective temperature
% temp = v.a .* v.T_surface + (1-v.a) .* v.T_deep;
v.qd = (p.Q10d^0.1) .^ v.temp;
v.qg = (p.Q10g^0.1) .^ v.temp;


% development: D(t) ------------------------------------------------------------
isalive = v.t >= t0_3d; % spawned yet?
dDdt = isalive .* p.u0 .* v.qd; % nonfeeding formula
v.D = cumsum(dDdt) .* dt;
isfeeding = v.D >= p.Df;
dDdt_feeding = isalive .* p.u0 .* v.qd .* v.a .* v.sat;
dDdt(isfeeding) = dDdt_feeding(isfeeding); % full formula 
v.D = cumsum(dDdt) .* dt;
v.D(v.D>1) = 1;
isfeeding = v.D >= p.Df; % recalculated because cumsum() is one timestep
						 % off from a true forward integration
% date of maturation, development time
isadult = v.D >= 1;
ta = v.t;
ta(~isadult) = inf;
v.ta = min(ta);
v.ta(~any(isadult)) = nan;
v.dtdev = v.ta - v.t0;


% pick a guess at adult size based on mean temperature in the forcing,
% and pick a corresponding guess at egg size based on this. These used to be
% called p.Wa0 and p.We0.
T_nominal = mean(v.temp);
qoverq = (p.Q10g./p.Q10d).^(T_nominal./10);
co = (1-p.theta) .* p.GGE_nominal .* (1-p.Df) .* qoverq;
v.Wa_theo = (co .* p.I0 ./ p.u0) .^ (1./(1-p.theta));
v.We_theo = p.r_ea .* v.Wa_theo .^ p.exp_ea;


% juvenile growth: W(t) --------------------------------------------------------
% approximate curve of W(D), valid for a=1
% this is used for the allometry in the calculation of net gain
isgrowing = isfeeding & v.D < 1;
satmean = sum(v.sat .* isgrowing) ./ sum(isgrowing);
c = (1-p.theta) .* v.qg ./ v.qd .* p.I0 ./ p.u0 .* ...
    (p.r_assim - p.rm ./ repmat(satmean,[NT 1 1]));
c = max(c,0);
Wapprox = zeros(size(v.D));
We_theo_3d = repmat(v.We_theo,[NT 1 1]);
Wapprox(isgrowing) = ((We_theo_3d(isgrowing).^(1-p.theta)) + ...
	c(isgrowing) .* (v.D(isgrowing) - p.Df)) .^ (1/(1-p.theta));
% net gain over development (here stored as gain * W)
ImaxW = v.qg .* p.I0 .* Wapprox .^ p.theta;
	% only used at (isgrowing=1), not necessarily accurate beyond that
astar = p.rb + (1-p.rb) .* v.a;
GW = zeros(size(v.D));
GW(isgrowing) = ImaxW(isgrowing) .* ...
	(v.a(isgrowing) .* p.r_assim .* v.sat(isgrowing) - ...
	p.rm .* astar(isgrowing));
% integrate to get the correct W over development
v.W = We_theo_3d + cumsum(GW) .* dt;
v.W = max(0,v.W);
% adult size Wa
last = v.D(1:end-1,:,:) < 1 & v.D(2:end,:,:)==1;
v.Wa = max(v.W(1:end-1,:,:) .* last);
Wa_3d = repmat(v.Wa,[NT 1 1]);
v.W(isadult) = Wa_3d(isadult);
% calculate net gain during adulthood (used later to calculate egg production)
% and fill in juvenile ingestion, metabolism, and net gain while we're at it
Imax = v.qg .* p.I0 .* v.W.^(p.theta-1);
Imax(~isfeeding) = 0;
Imax(v.W < We_theo_3d) = 0;
v.I = v.a .* p.r_assim .* v.sat .* Imax;
	% this was r_assim * I, as opposed to I, in Coltrane 1.0
v.M = p.rm .* astar .* Imax;
v.G = v.I - v.M;
% size relative to largest size previously attained
v.Wrel = v.W ./ cummax(v.W);


% mortality and survivorship: N(t) ---------------------------------------------
v.m = p.m0 .* v.qg .* v.a .* v.W.^(p.theta-1); % mort. rate at T, size
v.m(~isalive) = 0;
v.lnN = cumsum(-v.m) .* dt;
% adult recruitment
lnNa = v.lnN;
lnNa(~isadult) = nan;
v.Na = exp(max(lnNa));


% egg production and fitness ---------------------------------------------------
% one-generation calculation, ignores timing and internal life-history mismatch
Einc = max(0, v.G .* v.W);
Einc(~isadult) = 0;
v.Finc = sum(Einc.*exp(v.lnN)) .* dt ./ v.We_theo;
	% lifetime eggs per egg, from adult accumulation of energy (income)
v.Fcap = p.capitalEfficiency .* v.Wa .* v.Na ./ v.We_theo;
	% lifetime eggs per egg, from juvenile accumulation of energy (capital).
	% capitalEfficiency is the fraction of adult body size that is assumed to be
	% convertible into eggs (similar to R/(R+S) in Coltrane 1.0)
v.F = v.Finc + v.Fcap;
v.capfrac = v.Fcap ./ v.F;


% clean up ---------------------------------------------------------------------
fields = fieldnames(v);
for i=1:length(fields)
	if size(v.(fields{i}),1) == size(v.t,1) && ~strcmpi(fields{i},'t')
		v.(fields{i})(~isalive) = nan;
			% nothing happened before they were born
	end
end


% metrics of viability and other classifications -------------------------------
[yr0,~] = datevec(v.t0);
yr0 = reshape(yr0,[1 NP NC]);
[yra,~] = datevec(v.ta);
yra = reshape(yra,[1 NP NC]);
v.numWinters = (yra - yr0);
	% how many winters to reach adulthood (should be <= 1)
first31dec = repmat(reshape(datenum(yr0,12,31), [1 NP NC]), [NT 1 1]);
is31dec = abs(v.t-first31dec) == ...
			  repmat(min(abs(v.t-first31dec)),[NT 1 1]);
v.D_winter = reshape(v.D(is31dec),[1 NP NC]);
	% D in middle of first winter (should be > params.Ddia)
v.starv_stress = max((1 - v.Wrel)./v.D);
	% starvation stress. % this should be less than some threshhold c which is 
	% equivalent to the criterion Wrel >= 1 - c*D (e.g., if c=0.5, then animals 
	% are allowed to metabolise half their body mass at adulthood)
n0 = reshape(find(v.t == t0_3d),[1 NP NC]);
v.x0 = v.x(n0); % locate the cohort in space at spawning (t0)
v.y0 = v.y(n0);
v.H0 = v.H(n0);
v.activeSpawning = (v.a(n0) > 0); % spawned during an active period?
n1yr = reshape(find(v.t == t0_3d + round(365/dt)*dt),[1 NP NC]);
v.x1yr = v.x(n1yr); % locate the cohort 1 year after spawning
v.y1yr = v.y(n1yr);
v.H1yr = v.H(n1yr);

% summary of metrics available:
% 	 development (based on D)
% 		t0, dtdev
%		numWinters
%		D_winter
%		activeSpawning
%		x0, y0, H0, x1yr, y1yr, H1yr
%    growth and energetics (based on D + W,G)
%		Wa
%		starv_stress
%	 population dynamics (based on D + W,G + N,E)
%		F
%		Finc, Fcap, capfrac
%		Na
% the usual next step is to use these to select a subset in filterCohorts.m
