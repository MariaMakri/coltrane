function [v,vw,vo] = coltraneModel(forcing,p);

% v = coltraneModel(forcing,p);
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% forcing is a structure specifying a single time series of forcing and 
% 		ancillary variables. Cohorts are generated by varying spawning date
% 		across the first year.
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * This is actually an approximate solution which doesn't require iteration 
%		across all state variables in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,W),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are considered in a brute-force way parallel
% 		to spawning date.
% * tegg has been replaced by dtegg, which is similar to (tegg - t0):
%
%	NT			NC			NDx			NDn			NE
%	t			t0			tdia_exit	tdia_enter	dtegg
%	timestep	spawn date	exit date	entry date	egg prod date
%	(calendar)	(calendar)	(yearday)	(yearday)	(relative to t0)


% calculate yearday, if it wasn't supplied
if ~isfield(forcing,'yday')
	forcing.yday = reshape(yearday(forcing.t),size(forcing.t));
end
NT = size(forcing.t,1); % # timesteps
% determine the simulation timestep from the forcing time series
dt = forcing.t(2) - forcing.t(1);

t0 = forcing.t(1) + (0 : p.dt_spawn : 365); % the spawning dates to consider
NC = length(t0);
tdia_exit = 0 : p.dt_dia : 365/2; % diapause exit yeardays
NDx = length(tdia_exit);
tdia_enter = (max(tdia_exit) + p.dt_dia) : p.dt_dia : 365; % entry dates
NDn = length(tdia_enter);
dteggmin = (p.min_genlength_years - 0.5) .* 365;
dteggmin = max(dteggmax, p.dt_tspawn);
dteggmax = (p.max_genlength_years + 0.5) .* 365;
dteggmax = min(dteggmax, forcing.t(end) - t0(end));
dtegg = dteggmin : p.dt_spawn : dteggmax;
	% the date that egg production begins relative to t0
NE = length(dtegg);

% set up a [NT NC NDx NDn] structure appropriate for a single value of dtegg
fields = fieldnames(forcing);
for i=1:length(fields)
	v0.(fields{i}) = repmat(forcing.(fields{i}),[1 NC NDx NDn]);
end
v0.t0 = repmat(reshape(t0, [1 NC 1]), [1 1 NDx NDn]);
v0.tdia_exit = repmat(reshape(tdia_exit, [1 1 NDx 1]), [1 NC 1 NDn]);
v0.tdia_enter = repmat(reshape(tdia_enter, [1 1 1 NDn]), [1 NC NDx 1]);

% for each value of dtegg...
for i = 1:NE
	disp(num2str(i));
	forceCompletion = (i==1);
	
	% calculate development, growth, mortality, egg production, and 
	% one-generation fitness: a(t), D(t), W(t), E(t), N(t), LEP1
	vi = coltrane_oneMaturationDate(v0,p,dtegg(i),forceCompletion);
	
	% if the run stopped early because v.D is inconsistent with dtegg, just
	% leave this slice filled with nans and move along
	if isempty(vi.D), continue; end
	
	% keep selected full time series ...
	timeSeriesToKeep = {'D','lnN','E'};
	for k=1:length(timeSeriesToKeep)
		thevar = timeSeriesToKeep{k};
		if i==1, v.(thevar) = repmat(nan,[NT NC NDx NDn NE]); end
		v.(thevar)(:,:,:,:,i) = vi.(thevar);
	endq
	% ... and all scalars
	fields = fieldnames(vi);
	for k=1:length(fields)
		if size(vi.(fields{k}),1)==1
			if i==1, v.(fields{k}) = repmat(nan,[1 NC NDx NDn NE]); end
			v.(fields{k})(:,:,:,:,i) = vi.(fields{k});
		end
	end
	
	% consolidate over the diapause-strategy dimensions
	vi.diaStrategyFrac_4d = repmat(vi.diaStrategyFrac,[NT 1 1 1]);
	vi.diaStrategyFrac_opt_4d = repmat(vi.diaStrategyFrac_opt,[NT 1 1 1]);
	for k=1:length(fields)
		N1 = size(vi.(fields{k}),1);
		if N1==1
			if i==1, vw.(fields{k}) = repmat(nan,[1 NC NE]); end
			var_w = vi.(fields{k}) .* vi.diaStrategyFrac;
			var_w(isnan(var_w)) = 0;
			vw.(fields{k})(:,:,i) = squeeze(sum(sum(var_w,3),4));
			var_w = vi.(fields{k}) .* vi.diaStrategyFrac_opt;
			var_w(isnan(var_w)) = 0;
			vo.(fields{k})(:,:,i) = squeeze(sum(sum(var_w,3),4));
		else
			if i==1, vo.(fields{k}) = repmat(nan,[NT NC NE]); end
			var_w = vi.(fields{k}) .* vi.diaStrategyFrac_4d;
			var_w(isnan(var_w)) = 0;
			vw.(fields{k})(:,:,i) = squeeze(sum(sum(var_w,3),4));
			var_w = vi.(fields{k}) .* vi.diaStrategyFrac_opt_4d;
			var_w(isnan(var_w)) = 0;
			vo.(fields{k})(:,:,i) = squeeze(sum(sum(var_w,3),4));
		end
	end
end

