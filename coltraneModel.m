function v = coltraneModel(particles,p,ind);

% v = bcc_coltraneModel(particles,p,ind);
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% particles is a structure specifying time series of forcing and ancillary 
%		variables along particle paths. Cohorts are generated by varying 
%		spawning date across the first year.
%		Note that these do not have to move in space, and in fact the spatial
%		coordinates aren't used in any way--perhaps a better term would be
%		"histories" or "cases."
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%		A nice improvement to this code would be to allow the timing-strategy
%		parameters--tdia_enter, tdia_exit, and (in a future version that uses 
%		it) tegg--to be vectors. For now, handle these the same as if you want
%		to run ensembles across vectors of the other parameters, by writing a 
%		wrapper function that calls coltraneModel in a loop.
% ind is a list of the indices into _particles_ to use. This makes it easy to 
%		run subsets of a big particle-release experiment.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * This is actually an approximate solution which doesn't require iteration 
%		across all state variables in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,W),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are considered in a brute-force way parallel
% 		to spawning date.


% setup ------------------------------------------------------------------------
% keep only particles with indices _ind_
if nargin < 3
	ind = 1:size(particles.t(:,:),2);
end
fields = fieldnames(particles);
for i=1:length(fields)
	particles.(fields{i}) = particles.(fields{i})(:,ind);
		% this is worth doing even if ind isn't specified, since it reshapes
		% dimensions 2,3,... into a flat list
end
% calculate yearday, if it wasn't supplied
if ~isfield(particles,'yday')
	particles.yday = reshape(yearday(particles.t),size(particles.t));
end
% and having done so, work in relative date, not calendar date. This makes it
% possible to run a single run across particles from multiple years
[NT,NP] = size(particles.t); % # timesteps, # particles
particles.calendar_date_offset = particles.t(1,:);
particles.t = particles.t - repmat(particles.t(1,:),[NT 1]);
% create cohorts by varying spawning date. This copies everything in _particles_
% over into the massive output structure v
dt = particles.t(2) - particles.t(1);
	% makes the simulation timestep match the forcing time series, rather than
	% the other way around

t0 = particles.t(1) + (0 : p.dt_spawn : 365); % the spawning dates to consider
NC = length(t0);
tdia_exit = particles.t(1) + (0 : p.dt_dia : 365/2); % diapause exit dates
NDx = length(tdia_exit);
tdia_enter = max(tdia_exit) + p.dt_dia : p.dt_dia : 365; % entry dates
NDn = length(tdia_enter);

%{
dimensions are
	NT			NP			NC			NDx			NDn
	timestep	particle	cohort/		exit date	entry date
							spawn date
so one timestep of the calculation has size [1 NP NC NDx NDn]
%}	
fields = fieldnames(particles);
for i=1:length(fields)
	v.(fields{i}) = repmat(particles.(fields{i}),[1 1 NC NDx NDn]);
end
v.t0 = repmat(reshape(t0,			 	  [1 1 NC 1 1]), [1 NP 1 NDx NDn]);
v.tdia_exit = repmat(reshape(tdia_exit,	  [1 1 1 NDx 1]),[1 NP NC 1 NDn]);
v.tdia_enter = repmat(reshape(tdia_enter, [1 1 1 1 NDn]),[1 NP NC NDx 1]);
t0_5d = repmat(v.t0,[NT 1 1 1 1]);

% prey saturation --------------------------------------------------------------
v = preySaturation(v,p);	
	
% activity: a(t)  --------------------------------------------------------------
tdia_exit_5d = repmat(v.tdia_exit,[NT 1 1 1 1]);
tdia_enter_5d = repmat(v.tdia_enter,[NT 1 1 1 1]);
v.a = ~(v.yday >= tdia_enter_5d | v.yday <= tdia_exit_5d);
	% assumes that tdia_enter > tdia_exit
v.a = double(v.a);
% keep track of average prey saturation during the a=0 and a=1 periods-
% this isn't used in the model but could be a useful diagnostic
v.sata0 = sum(v.sat .* double(v.a==0)) ./ sum(double(v.a==0));
v.sata1 = sum(v.sat .* double(v.a==1)) ./ sum(double(v.a==1));


% temperature response factors -------------------------------------------------
v.temp = v.a .* v.T0 + (1-v.a) .* v.Td;
v.qd = (p.Q10d^0.1) .^ v.temp;
v.qg = (p.Q10g^0.1) .^ v.temp;


% development: D(t) ------------------------------------------------------------
isalive = v.t >= t0_5d; % spawned yet?
dDdt = isalive .* p.u0 .* v.qd; % nonfeeding formula
v.D = cumsum(dDdt) .* dt;
isfeeding = v.D >= p.Df;
dDdt_feeding = isalive .* p.u0 .* v.qd .* v.a .* v.sat;
dDdt(isfeeding) = dDdt_feeding(isfeeding); % full formula 
v.D = cumsum(dDdt) .* dt;
v.D(v.D>1) = 1;
isfeeding = v.D >= p.Df; % recalculated because cumsum() is one timestep
						 % off from a true forward integration
% date of maturation, development time
isadult = v.D >= 1;
ta = v.t;
ta(~isadult) = inf;
v.ta = min(ta);
v.ta(~any(isadult)) = nan;
v.dtdev = v.ta - v.t0;


% pick a guess at adult size based on mean temperature in the forcing,
% and pick a corresponding guess at egg size based on this. These used to be
% called p.Wa0 and p.We0.
T_nominal = mean(v.temp);
qoverq = (p.Q10g./p.Q10d).^(T_nominal./10);
co = (1-p.theta) .* p.GGE_nominal .* (1-p.Df) .* qoverq;
v.Wa_theo = (co .* p.I0 ./ p.u0) .^ (1./(1-p.theta));
v.We_theo = p.r_ea .* v.Wa_theo .^ p.exp_ea;


% juvenile growth: W(t) --------------------------------------------------------
% approximate curve of W(D), valid for a=1
% this is used for the allometry in the calculation of net gain
isgrowing = isfeeding & v.D < 1;
satmean = sum(v.sat .* isgrowing) ./ sum(isgrowing);
c = (1-p.theta) .* v.qg ./ v.qd .* p.I0 ./ p.u0 .* ...
    (p.r_assim - p.rm ./ repmat(satmean,[NT 1 1 1 1]));
c = max(c,0);
Wapprox = zeros(size(v.D));
We_theo_5d = repmat(v.We_theo,[NT 1 1 1 1]);
Wapprox(isgrowing) = ((We_theo_5d(isgrowing).^(1-p.theta)) + ...
	c(isgrowing) .* (v.D(isgrowing) - p.Df)) .^ (1/(1-p.theta));
% net gain over development (here stored as gain * W)
ImaxW = zeros(size(Wapprox));
ImaxW(isgrowing) = v.qg(isgrowing) .* p.I0 .* Wapprox(isgrowing) .^ p.theta;
astar = p.rb + (1-p.rb) .* v.a;
GW = zeros(size(v.D));
GW(isgrowing) = ImaxW(isgrowing) .* ...
	(v.a(isgrowing) .* p.r_assim .* v.sat(isgrowing) - ...
	p.rm .* astar(isgrowing));
% integrate to get the correct W over development
v.W = We_theo_5d + cumsum(GW) .* dt;
v.W = max(0,v.W);
% adult size Wa
last = v.D(1:end-1,:,:,:,:) < 1 & v.D(2:end,:,:,:,:)==1;
v.Wa = max(v.W(1:end-1,:,:,:,:) .* last);
Wa_5d = repmat(v.Wa,[NT 1 1 1 1]);
v.W(isadult) = Wa_5d(isadult);
% calculate net gain during adulthood (used later to calculate egg production)
% and fill in juvenile ingestion, metabolism, and net gain while we're at it
Imax = v.qg .* p.I0 .* v.W.^(p.theta-1);
Imax(~isfeeding) = 0;
Imax(v.W < We_theo_5d) = 0;
v.I = v.a .* p.r_assim .* v.sat .* Imax;
	% this was r_assim * I, as opposed to I, in Coltrane 1.0
v.M = p.rm .* astar .* Imax;
v.G = v.I - v.M;
v.Wrel = v.W ./ cummax(v.W); % size relative to largest size previously attained


% mortality and survivorship: N(t) ---------------------------------------------
v.m = p.m0 .* v.qg .* v.a .* v.W.^(p.theta-1); % mort. rate at T, size
v.m(~isalive) = 0;
v.lnN = cumsum(-v.m) .* dt;
% adult recruitment
lnNa = v.lnN;
lnNa(~isadult) = nan;
v.Na = exp(max(lnNa));


% egg production and fitness ---------------------------------------------------
% one-generation calculation, ignores timing and internal life-history mismatch
Einc = max(0, v.G .* v.W);
Einc(~isadult) = 0;
v.Finc = sum(Einc.*exp(v.lnN)) .* dt ./ v.We_theo;
	% lifetime eggs per egg, from adult accumulation of energy (income)
v.Fcap = p.capitalEfficiency .* v.Wa .* v.Na ./ v.We_theo;
	% lifetime eggs per egg, from juvenile accumulation of energy (capital).
	% capitalEfficiency is the fraction of adult body size that is assumed to be
	% convertible into eggs (similar to R/(R+S) in Coltrane 1.0)
v.F = v.Finc + v.Fcap;
v.capfrac = v.Fcap ./ v.F;


% clean up ---------------------------------------------------------------------
fields = fieldnames(v);
for i=1:length(fields)
	if size(v.(fields{i}),1) == NT && ~strcmpi(fields{i},'t')
		v.(fields{i})(~isalive) = nan;
	end
end


% metrics of viability and other classifications -------------------------------
[yr0,~] = datevec(v.t0);
yr0 = reshape(yr0,[1 NP NC NDx NDn]);
[yra,~] = datevec(v.ta);
yra = reshape(yra,[1 NP NC NDx NDn]);
v.numWinters = (yra - yr0);
	% how many winters to reach adulthood (should be <= 1)
first31dec = repmat(reshape(datenum(yr0,12,31), [1 NP NC NDx NDn]), ...
												[NT 1 1 1 1]);
is31dec = abs(v.t-first31dec) == ...
			  repmat(min(abs(v.t-first31dec)),[NT 1 1 1 1]);
v.D_winter = reshape(v.D(is31dec),[1 NP NC NDx NDn]);
	% D in middle of first winter (should be > params.Ddia)
v.starv_stress = max((1 - v.Wrel)./v.D);
	% starvation stress. % this should be less than some threshhold c which is 
	% equivalent to the criterion Wrel >= 1 - c*D (e.g., if c=0.5, then animals 
	% are allowed to metabolise half their body mass at adulthood)
n0 = reshape(find(v.t == t0_5d),[1 NP NC NDx NDn]);
if isfield(v,'x')
	v.x0 = v.x(n0); % locate the cohort in space at spawning (t0)
	v.y0 = v.y(n0);
	v.H0 = v.H(n0);
end
v.activeSpawning = (v.a(n0) > 0); % spawned during an active period?
n1yr = reshape(find(v.t == t0_5d + round(365/dt)*dt),[1 NP NC NDx NDn]);
if isfield(v,'x')
	v.x1yr = v.x(n1yr); % locate the cohort 1 year after spawning
	v.y1yr = v.y(n1yr);
	v.H1yr = v.H(n1yr);
end

% summary of metrics available:
% 	 development (based on D)
% 		t0, dtdev
%		numWinters
%		D_winter
%		activeSpawning
%		x0, y0, H0, x1yr, y1yr, H1yr
%    growth and energetics (based on D + W,G)
%		Wa
%		starv_stress
%	 population dynamics (based on D + W,G + N,E)
%		F
%		Finc, Fcap, capfrac
%		Na
% the usual next step is to use these to select a subset in filterCohorts.m
