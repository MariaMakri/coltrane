function v = coltraneModel(forcing,p);

% v = coltraneModel(forcing,p);
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% forcing is a structure specifying a single time series of forcing and 
% 		ancillary variables. Cohorts are generated by varying spawning date
% 		across the first year.
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * This is actually an approximate solution which doesn't require iteration 
%		across all state variables in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,W),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are considered in a brute-force way parallel
% 		to spawning date.


% calculate yearday, if it wasn't supplied
if ~isfield(forcing,'yday')
	forcing.yday = reshape(yearday(forcing.t),size(forcing.t));
end
NT = size(forcing.t,1); % # timesteps
% determine the simulation timestep from the forcing time series
dt = forcing.t(2) - forcing.t(1);

%	NT			NC			NDx			NDn			NAd
%	timestep	cohort/		exit date	entry date	maturation date
%				spawn date
t0 = forcing.t(1) + (0 : p.dt_spawn : 365); % the spawning dates to consider
NC = length(t0);
tdia_exit = 0 : p.dt_dia : 365/2; % diapause exit yeardays
NDx = length(tdia_exit);
tdia_enter = (max(tdia_exit) + p.dt_dia) : p.dt_dia : 365; % entry dates
NDn = length(tdia_enter);
tadult = forcing.t(1) : p.dt_spawn : forcing.t(end); % dates of maturation
	% figuring out how to run only a subset of the tadult cases would be a big
	% efficiency boost
NAd = length(tadult);

% set up a [NT NC NDx NDn] structure appropriate for a single value of tadult
fields = fieldnames(forcing);
for i=1:length(fields)
	v0.(fields{i}) = repmat(forcing.(fields{i}),[1 NC NDx NDn]);
end
v0.t0 = repmat(reshape(t0, [1 NC 1]), [1 1 NDx NDn]);
v0.tdia_exit = repmat(reshape(tdia_exit, [1 1 NDx 1]), [1 NC 1 NDn]);
v0.tdia_enter = repmat(reshape(tdia_enter, [1 1 1 NDn]), [1 NC NDx 1]);

% for each value of tadult...
for i = 1:NAd
	disp(num2str(i));
	
	% calculate development, growth, mortality, egg production, and 
	% one-generation fitness: a(t), D(t), W(t), E(t), N(t), LEP1
	vi = coltrane_oneMaturationDate(v0,p,tadult(i));
	
	% define viability--i.e. an additional filter on LEP1
	% vi.viable = vi.activeSpawning & vi.starv_stress < 1;
	vi.viable = vi.starv_stress < 1;
	vi.LEP1 = vi.LEP1 .* vi.viable;
	% relative contributions of each diapause strategy to the total fitness
	% of each t0 cohort (at a given tadult)
	vi.diaStrategyFrac = vi.LEP1 ./ ...
		repmat(sum(sum(vi.LEP1,3),4), [1 1 NDx NDn]);
	
	% keep selected time series ...
	timeSeriesToKeep = {'a','D','G','W','lnN','E'};
	for k=1:length(timeSeriesToKeep)
		thevar = timeSeriesToKeep{k};
		if i==1, v.(thevar) = repmat(nan,[NT NC NDx NDn NAd]); end
		v.(thevar)(:,:,:,:,i) = vi.(thevar);
	end
	% ... and all scalars
	fields = fieldnames(vi);
	for k=1:length(fields)
		if size(vi.(fields{k}),1)==1
			if i==1, v.(fields{k}) = repmat(nan,[1 NC NDx NDn NAd]); end
			v.(fields{k})(:,:,:,:,i) = vi.(fields{k});
		end
	end
end

