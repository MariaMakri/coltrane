function v = coltraneModel(forcing,p,whatToSave);

% v = coltraneModel(forcing, p, 'scalars only' | 'scalars and fitness' | 'everything');
%
% "dia18" (DIAPOD, 2018) version of the Coltrane model. This has diverged 
% significantly from the Coltrane 1.0 model used in Banas et al. 2016: it's 
% closest to the "separable" branch on github.
%
% forcing is a structure specifying a single time series of forcing and 
% 		ancillary variables. Cohorts are generated by varying spawning date
% 		across the first year.
% p is a structure containing the internal model parameters. These should
%		all be scalars.
%
% relationship with the published Coltrane model (Front. Mar. Res. 2016):
% * the phi model is hereby abandoned
% * R,S are collapsed into a single state variable W = S + R. Allometric
%		formulas using S in the paper now use W.
% * the state variables have been largely separated so that not all parts
% 		require iteration in time. This makes the model cleanly 
% 		hierarchical, so that one can derive predictions about
%				development alone (D),
% 				then size and time evolution in surviving cohorts (D,Wpro),
% 				then mortality, survivorship, and population dynamics (D,W,N).
%		This will also make it possible for N to be density-dependent in a 
%		future version.
% * The myopic criterion for diapause has been replaced by a matrix of entry
%		and exit dates, which are considered in a brute-force way parallel
% 		to spawning date.
% * tegg has been replaced by dtegg, which is similar to (tegg - t0):
%
%	t			t0			tdia_exit	tdia_enter	dtegg
%	timestep	spawn date	exit date	entry date	egg prod date
%	(calendar)	(calendar)	(yearday)	(yearday)	(relative to t0)
%
% the last three dimensions are folded into a single strategy vector s.


if nargin < 3, whatToSave = 'scalars only'; end


NT = size(forcing.t,1); % # timesteps
[t0,s] = timingCombinations(forcing,p);
strategyFields = fieldnames(s);
NC = length(t0);
NS = prod(size(s.(strategyFields{1})));


% run one strategy at a time
out = cell(1,NS);
parfor i = 1:NS
	si = selectRows(s,i);
	out{i} = coltrane_integrate(forcing,p,t0,si,whatToSave);
end


% rearrange into something more useful
for i = 1:NS
	v.F1(:,i) = out{i}.F1(:);
	v.F2(:,i) = out{i}.F2(:);
end
f = find(any(v.F1>0));
if isempty(f), return; end
fields = setdiff(fieldnames(out{f(1)}),{'F1','F2'});
for k = 1:length(fields)
	for i=1:NS
		if isfield(out{i},fields{k}) && ~isempty(out{i}.(fields{k})) ...
			v.(fields{k})(:,:,i) = squeeze(out{i}.(fields{k}));
		end
	end
end



